package main

import "fmt"

// Printer
// Новый интерфейс, ожидаемый клиентом
type Printer interface {
	Print()
}

// OldPrinter
// Старая структура с другим методом
type OldPrinter struct{}

func (op *OldPrinter) PrintOld() {
	fmt.Println("печать через старый принтер")
}

// Adapter
// Адаптер, реализующий интерфейс Printer, делегирующий вызов OldPrinter
type Adapter struct {
	oldPrinter *OldPrinter
}

func (a *Adapter) Print() {
	a.oldPrinter.PrintOld() // делегируем вызов
}

func main() {
	old := &OldPrinter{}
	adapter := &Adapter{oldPrinter: old}

	// клиент работает с интерфейсом Printer
	var printer Printer = adapter
	printer.Print() // печать через старый принтер
}

/*
Клиент ожидает Printer с методом Print()
В коде есть OldPrinter с PrintOld(), Adapter реализует Printer и вызывает PrintOld() внутри себя
Т.е. был адаптирован несовместимый интерфейс под интерфейс, который ожидает клиент

Плюсы:
	Устраняет несовместимость интерфейсов
	Обеспечивает гибкость и расширяемость
	Позволяет использовать уже существующий код
	Изменения в одном адаптере не влияют на остальную чатсь кода

Минусы:
	Добавляет доп. уровень абстракции и может усложнять архитектуру
	Немного влияет на производительность за счет вызовы доп. метода

Кейсы для паттерна:
	Взаимодействие с устаревшими API (легаси системы), когда нужно интегрировать с новым интерфейсом
	Адаптер позволяет постепенно переходить с одной версии API на другую, не ломая клиентский код
	Обеспечение платформенной независимости: адаптеры помогают скрыть различия между платформами (например, разные ОС), предоставляя единый интерфейс
	Для тестирования, например, для создания моков, адаптируя реальные компоненты под тестовые интерфейсы
*/
