package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}

/*

Вывод программы:
	nil
	false

Интерфейс (непустой) состоит из указателя на значение и указателя на таблицу методов
В функции Foo переменной err присваивается значение nil, т.е. получилась следующая ситуация,
что один указатель равен nil (указатель на data), а другой указатель (указатель на itab) не равен nil.
Поэтому, если проверять в main переменную err на то, равна ли она nil, то результат будет false
Аналогично, с пустым интерфейсом interface{} при присвоении nil указателя на структуру ситуация та же: указатель на тип не nil, указатель на значение nil

Пустой интерфейс (в runtime-представлении (eface)) состоит из 2 указателей: указателя на тип и на значение
Пустой интерфейс может хранить что угодно

var person *Person = nil
var i interface{} = p
fmt.Println(i == nil) // false

В этом случае у переменной-интерфейса i тип это Person, а значение nil,
т.е. снова такая ситуация, что один указатель (указатель на тип) не равен nil, а другой указатель (указатель на значени) равен nil

*/
