package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"
)

// А это, скажем так, изолированная версия завершения по Ctrl + C
// Тут чисто реализация завершения по Ctrl + C
// Полная версия находится в файле L1.3.go, он прям над этим файлом ("этот файл" -- L1.4.go)
func main() {
	shutdownCtx, shutdownCancel := context.WithCancel(context.Background())
	defer shutdownCancel()

	signalCh := make(chan os.Signal, 1)
	signal.Notify(signalCh, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		for {
			select {
			case <-shutdownCtx.Done():
				fmt.Println("получен сигнал завершения, горутина завершается")
				return
			default:
				fmt.Println("работаю...")
				time.Sleep(1 * time.Second)
			}
		}
	}()

	select {
	case sig := <-signalCh:
		fmt.Println("получен сигнал:", sig)
		signal.Stop(signalCh) // чтобы не получать сигнал ещё раз
	case <-shutdownCtx.Done():
		fmt.Println("завершаем работу")
	}
}

/*
1. Контекст для управления жизненным циклом горутин
context.WithCancel() предоставляет удобный способ оповещения горутин о необходимости завершения. Горутины, которые принимают этот
конекст, могут одновременно реагировать на отмену, проверяя ctx.Done().

ContextWithTimeout можно было бы использовать
	если бы было ограничение по времени на выполнение операции;
	нужно аварийно завершить работу через N секунд, даже если сигнал не пришёл
Но по условию задачи программа должна постоянно работать

2. Канал для сигналов
signalChannel "подписан" на системные сигналы syscall.SIGINT и syscall.SIGTERM. Это базовый спосбо обработки прерываний в Го

3. Запуск горутины с циклом, который периодически проверяет контекст
В отдельной горутине цикл с select между <-ctx.Done() и default позволяет эффективно отслеживать отмену контекста,
при этом выполняя основную работу. Такой цикл:
	без задержек реагирует на отмену
	позволяет не блокировать основной поток
	позволяет корректно завершать работу

4. Главный select для ожидания либо сигнала, либо отмены контекста
В main с помощью select программа ждёт либо получения сигнала прерывания,
либо если контекст уже отменён (например, по другим причинам)

5. defer shutdownCancel() как запасной механизм
Если по каким-то причинам main завершится, defer вызовет shutdownCancel(),
предотвращая «утечки» горутин, которые могли остаться висеть
*/
